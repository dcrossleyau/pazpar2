/* $Id: test_icu_I18N.c,v 1.16 2007-05-11 08:27:29 marc Exp $
   Copyright (c) 2006-2007, Index Data.

   This file is part of Pazpar2.

   Pazpar2 is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2, or (at your option) any later
   version.

   Pazpar2 is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   for more details.

   You should have received a copy of the GNU General Public License
   along with Pazpar2; see the file LICENSE.  If not, write to the
   Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.
*/

// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8
 

#if HAVE_CONFIG_H
#include "cconfig.h"
#endif

#define USE_TIMING 0
#if USE_TIMING
#include <yaz/timing.h>
#endif

#include <yaz/test.h>



#ifdef HAVE_ICU
#include "icu_I18N.h"

#include <string.h>
#include <stdlib.h>

//#include <unicode/ustring.h>  
// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8


#define MAX_KEY_SIZE 256
struct icu_termmap
{
    uint8_t sort_key[MAX_KEY_SIZE]; // standard C string '\0' terminated
    char disp_term[MAX_KEY_SIZE];  // standard C utf-8 string
};



int icu_termmap_cmp(const void *vp1, const void *vp2)
{
    struct icu_termmap *itmp1 = *(struct icu_termmap **) vp1;
    struct icu_termmap *itmp2 = *(struct icu_termmap **) vp2;

    int cmp = 0;
    
    cmp = strcmp((const char *)itmp1->sort_key, 
                 (const char *)itmp2->sort_key);
    return cmp;
};




int test_icu_casemap(const char * locale, char action,
                     const char * src8cstr, const char * chk8cstr)
{
    int success = 0;
    UErrorCode status = U_ZERO_ERROR;

    struct icu_buf_utf8 * src8 = icu_buf_utf8_create(0);
    struct icu_buf_utf8 * dest8 = icu_buf_utf8_create(0);
    struct icu_buf_utf16 * src16 = icu_buf_utf16_create(0);
    struct icu_buf_utf16 * dest16 = icu_buf_utf16_create(0);


    int src8cstr_len = strlen(src8cstr);
    int chk8cstr_len = strlen(chk8cstr);

    // converting to UTF16
    icu_utf16_from_utf8_cstr(src16, src8cstr, &status);

    // perform case mapping
    icu_utf16_casemap(dest16, src16, locale, action, &status);
  
    // converting to UTF8
    icu_utf16_to_utf8(dest8, dest16, &status);
      

  
    // determine success
    if (dest8->utf8 
        && (dest8->utf8_len == strlen(chk8cstr))
        && !strcmp(chk8cstr, (const char *) dest8->utf8))
        success = 1;
    else
        success = 0;

    // report failures
    if (!success){
        printf("\nERROR\n");
        printf("original string:   '%s' (%d)\n", src8cstr, src8cstr_len);
        printf("icu_casemap '%s:%c' '%s' (%d)\n", 
               locale, action, dest8->utf8, dest8->utf8_len);
        printf("expected string:   '%s' (%d)\n", chk8cstr, chk8cstr_len);
    }
  
    // clean the buffers  
    icu_buf_utf8_destroy(src8);
    icu_buf_utf8_destroy(dest8);
    icu_buf_utf16_destroy(src16);
    icu_buf_utf16_destroy(dest16);
  
  
    return success;
}



// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8

void test_icu_I18N_casemap(int argc, char **argv)
{

    // Locale 'en'

    // sucessful tests
    YAZ_CHECK(test_icu_casemap("en", 'l',
                               "A ReD fOx hunTS sQUirriLs", 
                               "a red fox hunts squirrils"));
    
    YAZ_CHECK(test_icu_casemap("en", 'u',
                               "A ReD fOx hunTS sQUirriLs", 
                               "A RED FOX HUNTS SQUIRRILS"));
    
    YAZ_CHECK(test_icu_casemap("en", 'f',
                               "A ReD fOx hunTS sQUirriLs", 
                               "a red fox hunts squirrils"));
    
    YAZ_CHECK(test_icu_casemap("en", 't',
                               "A ReD fOx hunTS sQUirriLs", 
                               "A Red Fox Hunts Squirrils"));
    

    // Locale 'da'

    // sucess expected    
    YAZ_CHECK(test_icu_casemap("da", 'l',
                               "åh ÆbLE, øs fLØde i Åen efter bLåBærGRødeN", 
                               "åh æble, øs fløde i åen efter blåbærgrøden"));

    YAZ_CHECK(test_icu_casemap("da", 'u',
                               "åh ÆbLE, øs fLØde i Åen efter bLåBærGRødeN", 
                               "ÅH ÆBLE, ØS FLØDE I ÅEN EFTER BLÅBÆRGRØDEN"));

    YAZ_CHECK(test_icu_casemap("da", 'f',
                               "åh ÆbLE, øs fLØde i Åen efter bLåBærGRødeN", 
                               "åh æble, øs fløde i åen efter blåbærgrøden"));

    YAZ_CHECK(test_icu_casemap("da", 't',
                               "åh ÆbLE, øs fLØde i Åen efter bLåBærGRødeN", 
                               "Åh Æble, Øs Fløde I Åen Efter Blåbærgrøden"));

    // Locale 'de'

    // sucess expected    
    YAZ_CHECK(test_icu_casemap("de", 'l',
                               "zWÖlf ärgerliche Würste rollen ÜBer die StRAße",
                               "zwölf ärgerliche würste rollen über die straße"));

    YAZ_CHECK(test_icu_casemap("de", 'u',
                               "zWÖlf ärgerliche Würste rollen ÜBer die StRAße",
                               "ZWÖLF ÄRGERLICHE WÜRSTE ROLLEN ÜBER DIE STRASSE"));

    YAZ_CHECK(test_icu_casemap("de", 'f',
                               "zWÖlf ärgerliche Würste rollen ÜBer die StRAße",
                               "zwölf ärgerliche würste rollen über die strasse"));

    YAZ_CHECK(test_icu_casemap("de", 't',
                               "zWÖlf ärgerliche Würste rollen ÜBer die StRAße",
                               "Zwölf Ärgerliche Würste Rollen Über Die Straße"));

}


// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8

int test_icu_sortmap(const char * locale, int src_list_len,
                     const char ** src_list, const char ** chk_list)
{
    int success = 1;

    UErrorCode status = U_ZERO_ERROR;

    struct icu_buf_utf8 * buf8 = icu_buf_utf8_create(0);
    struct icu_buf_utf16 * buf16 = icu_buf_utf16_create(0);

    int i;

    struct icu_termmap * list[src_list_len];

    UCollator *coll = ucol_open(locale, &status); 
    icu_check_status(status);

    if(U_FAILURE(status))
        return 0;

    // assigning display terms and sort keys using buf 8 and buf16
    for( i = 0; i < src_list_len; i++) 
        {

            list[i] = (struct icu_termmap *) malloc(sizeof(struct icu_termmap));

            // copy display term
            strcpy(list[i]->disp_term, src_list[i]);    

            // transforming to UTF16
            icu_utf16_from_utf8_cstr(buf16, list[i]->disp_term, &status);
            icu_check_status(status);

            // computing sortkeys
            icu_sortkey8_from_utf16(coll, buf8, buf16, &status);
            icu_check_status(status);
    
            // assigning sortkeys
            memcpy(list[i]->sort_key, buf8->utf8, buf8->utf8_len);    
            //strncpy(list[i]->sort_key, buf8->utf8, buf8->utf8_len);    
            //strcpy((char *) list[i]->sort_key, (const char *) buf8->utf8);
        } 


    // do the sorting
    qsort(list, src_list_len, 
          sizeof(struct icu_termmap *), icu_termmap_cmp);

    // checking correct sorting
    for (i = 0; i < src_list_len; i++){
        if (0 != strcmp(list[i]->disp_term, chk_list[i])){
            success = 0;
        }
    }

    if(!success){
        printf("\nERROR\n"); 
        printf("Input str: '%s' : ", locale); 
        for (i = 0; i < src_list_len; i++) {
            printf(" '%s'", list[i]->disp_term); 
        }
        printf("\n");
        printf("ICU sort:  '%s' : ", locale); 
        for (i = 0; i < src_list_len; i++) {
            printf(" '%s'", list[i]->disp_term); 
            //printf("(%d|%d)", list[i]->sort_key[0],list[i]->sort_key[1]); 
        }
        printf("\n"); 
        printf("Expected:  '%s' : ", locale); 
        for (i = 0; i < src_list_len; i++) {
            printf(" '%s'", chk_list[i]); 
        }
        printf("\n"); 
    }
  
  
    ucol_close(coll);

    icu_buf_utf8_destroy(buf8);
    icu_buf_utf16_destroy(buf16);



    return success;  
}


// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8

void test_icu_I18N_sortmap(int argc, char **argv)
{

    // sucessful tests
    size_t en_1_len = 6;
    const char * en_1_src[6] = {"z", "K", "a", "A", "Z", "k"};
    const char * en_1_cck[6] = {"a", "A", "k", "K", "z", "Z"};
    YAZ_CHECK(test_icu_sortmap("en", en_1_len, en_1_src, en_1_cck));
    YAZ_CHECK(test_icu_sortmap("en_AU", en_1_len, en_1_src, en_1_cck));
    YAZ_CHECK(test_icu_sortmap("en_CA", en_1_len, en_1_src, en_1_cck));
    YAZ_CHECK(test_icu_sortmap("en_GB", en_1_len, en_1_src, en_1_cck));
    YAZ_CHECK(test_icu_sortmap("en_US", en_1_len, en_1_src, en_1_cck));
    
    // sucessful tests 
    size_t da_1_len = 6;
    const char * da_1_src[6] = {"z", "å", "o", "æ", "a", "ø"};
    const char * da_1_cck[6] = {"a", "o", "z", "æ", "ø", "å"};
    YAZ_CHECK(test_icu_sortmap("da", da_1_len, da_1_src, da_1_cck));
    YAZ_CHECK(test_icu_sortmap("da_DK", da_1_len, da_1_src, da_1_cck));
    
    // sucessful tests
    size_t de_1_len = 9;
    const char * de_1_src[9] = {"u", "ä", "o", "t", "s", "ß", "ü", "ö", "a"};
    const char * de_1_cck[9] = {"a","ä", "o", "ö", "s", "ß", "t", "u", "ü"};
    YAZ_CHECK(test_icu_sortmap("de", de_1_len, de_1_src, de_1_cck));
    YAZ_CHECK(test_icu_sortmap("de_AT", de_1_len, de_1_src, de_1_cck));
    YAZ_CHECK(test_icu_sortmap("de_DE", de_1_len, de_1_src, de_1_cck));
    
}


// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8

void test_icu_I18N_transliterator(int argc, char **argv)
{
    
    UErrorCode status = U_ZERO_ERROR;
    UParseError parse_error[256];

    const char * rules8cstr = "[:Punctuation:] Any-Remove";
    //const char * rules8cstr = "[:Control:] Any-Remove";
    //const char * rules8cstr = "[:Decimal_Number:] Any-Remove\n";
    //const char * rules8cstr = "[:Final_Punctuation:] Any-Remove";
    //const char * rules8cstr = "Lower; [:^Letter:] Remove";
    //const char * rules8cstr = "[:^Number:] Remove";
    //const char * rules8cstr = "Lower;[[:WhiteSpace:][:Punctuation:]] Remove";
    //const char * rules8cstr = "NFD; [:Nonspacing Mark:] Remove; NFC";
             
             
             
   
    const char * src8cstr = "Genesis 1\n"
        "The Beginning\n"
        "1 In the beginning God created the heavens and the earth.\n"
        "2 Now the earth was formless and empty, darkness was over "
        "the surface of the deep, and the Spirit of God was hovering "
        "over the waters.\n"
        "3 And God said, Let there be light, and there was light.\n";



    struct icu_buf_utf16 * rules16 = icu_buf_utf16_create(0);
    struct icu_buf_utf16 * src16 = icu_buf_utf16_create(0);
    struct icu_buf_utf16 * dest16 = icu_buf_utf16_create(0);
    struct icu_buf_utf8 * dest8 = icu_buf_utf8_create(0);

    icu_utf16_from_utf8_cstr(rules16, rules8cstr, &status);
    icu_check_status(status);

    icu_utf16_from_utf8_cstr(src16, src8cstr, &status);
    icu_check_status(status);

    UTransliterator * trans
        = utrans_openU(rules16->utf16, rules16->utf16_len,
                       UTRANS_FORWARD,
                       0, 0, 
                       parse_error, &status);

    //= utrans_openU(0, 0, UTRANS_FORWARD,
    //                   rules16->utf16, rules16->utf16_len, 
    //                   parse_error, &status);

    icu_check_status(status);
    if(U_FAILURE(status)) {
      printf("Parse Error: \n line %d offset %d \n '%s'\n", 
              parse_error->line, parse_error->offset,
             rules8cstr);
    }

    utrans_transUChars (trans, src16->utf16, &(src16->utf16_len),
                        src16->utf16_cap,
                        0, &(src16->utf16_len), &status);

    icu_utf16_to_utf8(dest8, src16, &status);
    icu_check_status(status);

    printf("Transliterator:\n%s\n", dest8->utf8);


    utrans_close (trans);
    icu_buf_utf16_destroy(rules16);
    icu_buf_utf16_destroy(src16);
    icu_buf_utf16_destroy(dest16);
    icu_buf_utf8_destroy(dest8);


#if 0
   
    icu_check_status(status);


  int32_t ustr16_lim = *ustr16_len;
    /* Transliterate a segment of a UChar* string */
    
    utrans_transUChars (trans, ustr16, &*ustr16_len,
                        ustr16_cap,
                        0, &ustr16_lim, &status);
    
    utrans_close (trans);

    printf("\n\nUnicode Set Patterns:\n"
             "   Pattern         Description\n"
             "   Ranges          [a-z]  The lower case letters a through z\n"
             "   Named Chars     [abc123] The six characters a,b,c,1,2 and 3\n"
             "   String          [abc{def}] chars a, b and c, and string 'def'\n"
             "   Categories      [\\p{Letter}] Perl General Category 'Letter'.\n"
             "   Categories      [:Letter:] Posix General Category 'Letter'.\n"
             "\n"
             "   Combination     Example\n"
             "   Union           [[:Greek:] [:letter:]]\n"
             "   Intersection    [[:Greek:] & [:letter:]]\n"
             "   Set Complement  [[:Greek:] - [:letter:]]\n"
             "   Complement      [^[:Greek:] [:letter:]]\n"
             "\n"
             "see: http://icu.sourceforge.net/userguide/unicodeSet.html\n"
             "\n"
             "Examples:\n"
             "   [:Punctuation:] Any-Remove\n"
             "   [:Cased-Letter:] Any-Upper\n"
             "   [:Control:] Any-Remove\n"
             "   [:Decimal_Number:] Any-Remove\n"
             "   [:Final_Punctuation:] Any-Remove\n"
             "   [:Georgian:] Any-Upper\n"
             "   [:Katakana:] Any-Remove\n"
             "   [:Arabic:] Any-Remove\n"
             "   [:Punctuation:] Remove\n"
             "   [[:Punctuation:]-[.,]] Remove\n"
             "   [:Line_Separator:] Any-Remove\n"
             "   [:Math_Symbol:] Any-Remove\n"
             "   Lower; [:^Letter:] Remove (word tokenization)\n"
             "   [:^Number:] Remove (numeric tokenization)\n"
             "   [:^Katagana:] Remove (remove everything except Katagana)\n"
             "   Lower;[[:WhiteSpace:][:Punctuation:]] Remove (word tokenization)\n"
             "   NFD; [:Nonspacing Mark:] Remove; NFC   (removes accents from characters)\n"
             "   [A-Za-z]; Lower(); Latin-Katakana; Katakana-Hiragana (transforms latin and katagana to hiragana)\n"
             "   [[:separator:][:start punctuation:][:initial punctuation:]] Remove \n"
             "\n"
             "see http://icu.sourceforge.net/userguide/Transform.html\n"
             "    http://www.unicode.org/Public/UNIDATA/UCD.html\n"
             "    http://icu.sourceforge.net/userguide/Transform.html\n"
             "    http://icu.sourceforge.net/userguide/TransformRule.html\n"
             );
#endif

}

// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8

int test_icu_tokenizer(const char * locale, char action,
                     const char * src8cstr, int count)
{
    int success = 1;

    UErrorCode status = U_ZERO_ERROR;
    struct icu_buf_utf16 * src16 = icu_buf_utf16_create(0);
    struct icu_buf_utf16 * tkn16 = icu_buf_utf16_create(0);
    struct icu_buf_utf8 * tkn8 = icu_buf_utf8_create(0);

    //printf("Input:  '%s'\n", src8cstr);

    // transforming to UTF16
    icu_utf16_from_utf8_cstr(src16, src8cstr, &status);
    icu_check_status(status);

    // set up tokenizer
    struct icu_tokenizer * tokenizer 
        = icu_tokenizer_create(locale, action, &status);
    icu_check_status(status);
    YAZ_CHECK(tokenizer);

    // attach text buffer to tokenizer
    icu_tokenizer_attach(tokenizer, src16, &status);    
    icu_check_status(status);
    YAZ_CHECK(tokenizer->bi);

    // perform work on tokens
    //printf("Tokens: ");
    while(icu_tokenizer_next_token(tokenizer, tkn16, &status)){
        icu_check_status(status);

        // converting to UTF8
        icu_utf16_to_utf8(tkn8, tkn16, &status);

        //printf("(%d)'%s' ", icu_tokenizer_token_id(tokenizer), tkn8->utf8);
        
        //printf("token %d %d %d %d '%s'\n",
        //       
        //       icu_tokenizer_token_start(tokenizer),
        //       icu_tokenizer_token_end(tokenizer),
        //       icu_tokenizer_token_length(tokenizer),
        //       tkn8->utf8);
    }
    //printf("\nTokens: %d\n", icu_tokenizer_token_count(tokenizer));


    if (count != icu_tokenizer_token_count(tokenizer)){
        success = 0;
        printf("\nTokenizer '%s:%c' Error: \n", locale, action);
        printf("Input:  '%s'\n", src8cstr);
        printf("Tokens: %d", icu_tokenizer_token_count(tokenizer));
        printf(", expected: %d\n", count);
    }

    icu_tokenizer_destroy(tokenizer);
    icu_buf_utf16_destroy(src16);
    icu_buf_utf16_destroy(tkn16);
    icu_buf_utf8_destroy(tkn8);
        
    return success;
}


// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8

void test_icu_I18N_tokenizer(int argc, char **argv)
{


    const char * en_str 
        = "O Romeo, Romeo! wherefore art thou Romeo?";
    
    YAZ_CHECK(test_icu_tokenizer("en", 's', en_str, 2));
    YAZ_CHECK(test_icu_tokenizer("en", 'l', en_str, 7));
    YAZ_CHECK(test_icu_tokenizer("en", 'w', en_str, 16));
    YAZ_CHECK(test_icu_tokenizer("en", 'c', en_str, 41));



    const char * da_str 
        = "Blåbærtærte. Denne kage stammer fra Finland. "
        "Den er med blåbær, men alle sommerens forskellige bær kan bruges.";
    
    YAZ_CHECK(test_icu_tokenizer("da", 's', da_str, 3));
    YAZ_CHECK(test_icu_tokenizer("dar", 'l', da_str, 17));
    YAZ_CHECK(test_icu_tokenizer("da", 'w', da_str, 37));
    YAZ_CHECK(test_icu_tokenizer("da", 'c', da_str, 110));

}





#endif // HAVE_ICU

// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8

int main(int argc, char **argv)
{

    YAZ_CHECK_INIT(argc, argv); 
    YAZ_CHECK_LOG();

#ifdef HAVE_ICU

    //test_icu_I18N_casemap_failures(argc, argv);
    test_icu_I18N_casemap(argc, argv);
    test_icu_I18N_sortmap(argc, argv);
    test_icu_I18N_transliterator(argc, argv);
    test_icu_I18N_tokenizer(argc, argv);

#else // HAVE_ICU

    printf("ICU unit tests omitted.\n"
           "Please install libicu36-dev and icu-doc or similar\n");
    YAZ_CHECK(0 == 0);

#endif // HAVE_ICU
   
    YAZ_CHECK_TERM;
}


// DO NOT EDIT THIS FILE IF YOUR EDITOR DOES NOT SUPPORT UTF-8



/*
 * Local variables:
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 * vim: shiftwidth=4 tabstop=8 expandtab
 */
